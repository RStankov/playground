// Generated by CoffeeScript 1.3.1

/*
 Backbone Handlebars

 Author: Radoslav Stankov
 Project site: https://github.com/RStankov/backbone-handlebars
 Licensed under the MIT License.
*/


(function() {
  var BH, _compile, _remove;

  BH = {
    VERSION: '1.0.0',
    postponed: {},
    rendered: {},
    postponeRender: function(name, options) {
      var cid, view, viewClass, _base;
      viewClass = _.inject((name || '').split('.'), (function(memo, fragment) {
        return memo[fragment] || false;
      }), window);
      if (!viewClass) {
        throw "Invalid view name - " + name;
      }
      view = new viewClass(options.hash);
      if (options.fn != null) {
        view.template = options.fn;
      }
      cid = options.data.view.cid;
      if ((_base = this.postponed)[cid] == null) {
        _base[cid] = [];
      }
      this.postponed[cid].push(view);
      return '<div id="_' + view.cid + '"></div>';
    },
    renderPostponed: function(parentView) {
      var cid;
      cid = parentView.cid;
      this.rendered[cid] = _.map(this.postponed[parentView.cid], function(view) {
        view.render();
        parentView.$("#_" + view.cid).replaceWith(view.el);
        return view;
      });
      return delete this.postponed[cid];
    },
    clearRendered: function(parentView) {
      var cid;
      cid = parentView.cid;
      if (this.rendered[cid]) {
        _.invoke(this.rendered[cid], 'remove');
        return delete this.rendered[cid];
      }
    }
  };

  Handlebars.registerHelper('view', function(name, options) {
    return new Handlebars.SafeString(BH.postponeRender(name, options));
  });

  Handlebars.registerHelper('views', function(name, models, options) {
    var callback, markers;
    callback = function(model) {
      options.hash.model = model;
      return BH.postponeRender(name, options);
    };
    markers = 'map' in models ? models.map(callback) : _.map(callback);
    return new Handlebars.SafeString(markers.join(''));
  });

  _compile = Handlebars.compile;

  Handlebars.compile = function(template, options) {
    if (options == null) {
      options = {};
    }
    options.data = true;
    return _compile.call(this, template, options);
  };

  Backbone.View.prototype.renderTemplate = function(context) {
    if (context == null) {
      context = {};
    }
    BH.clearRendered(this);
    this.$el.html(this.template(context, {
      data: {
        view: this
      }
    }));
    BH.renderPostponed(this);
    return this;
  };

  Backbone.View.prototype.renderedSubViews = function() {
    return BH.rendered[this.cid];
  };

  _remove = Backbone.View.prototype.remove;

  Backbone.View.prototype.remove = function() {
    BH.clearRendered(this);
    return _remove.apply(this, arguments);
  };

  Backbone.Handlebars = BH;

}).call(this);

// Generated by CoffeeScript 1.3.1

/*
 Backbone Handlebars

 Author: Radoslav Stankov
 Project site: https://github.com/RStankov/backbone-bind-to
 Licensed under the MIT License.
*/


(function() {
  var BackboneView, BindToView, bindTo, root, unbindFrom,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  root = this;

  BackboneView = root.Backbone.View;

  bindTo = function(object, events) {
    var eventName, methodName, _results;
    _results = [];
    for (eventName in events) {
      methodName = events[eventName];
      if (!this[methodName]) {
        throw new Error("Method " + methodName + " does not exists");
      }
      if (typeof this[methodName] !== 'function') {
        throw new Error("" + methodName + " is not a function");
      }
      _results.push(object.on(eventName, this[methodName], this));
    }
    return _results;
  };

  unbindFrom = function(object, events) {
    var eventName, methodName, _results;
    _results = [];
    for (eventName in events) {
      methodName = events[eventName];
      _results.push(object.off(eventName, this[methodName], this));
    }
    return _results;
  };

  BindToView = (function(_super) {

    __extends(BindToView, _super);

    BindToView.name = 'BindToView';

    function BindToView() {
      BindToView.__super__.constructor.apply(this, arguments);
      if (this.model) {
        bindTo.call(this, this.model, this.bindToModel);
      }
      if (this.collection) {
        bindTo.call(this, this.collection, this.bindToCollection);
      }
    }

    BindToView.prototype.remove = function() {
      BindToView.__super__.remove.apply(this, arguments);
      if (this.model) {
        unbindFrom.call(this, this.model, this.bindToModel);
      }
      if (this.collection) {
        return unbindFrom.call(this, this.collection, this.bindToCollection);
      }
    };

    return BindToView;

  })(BackboneView);

  Backbone.BindTo = {
    VERSION: '1.0.0',
    noConflict: function() {
      root.Backbone.View = BackboneView;
      return BindToView;
    },
    View: BindToView
  };

  root.Backbone.View = Backbone.BindTo.View;

}).call(this);

